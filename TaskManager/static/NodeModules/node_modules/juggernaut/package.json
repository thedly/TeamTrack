{
  "name": "juggernaut",
  "description": "Realtime PubSub server push.",
  "version": "2.1.1",
  "author": {
    "name": "maccman"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/maccman/juggernaut/blob/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/maccman/juggernaut.git"
  },
  "engine": [
    "node >=0.1.102"
  ],
  "main": "./index",
  "bin": {
    "juggernaut": "./server.js"
  },
  "dependencies": {
    "socket.io": "=0.8.7",
    "redis": "=0.6.6",
    "node-static-maccman": "~0.5.3",
    "optimist": "~0.2.3"
  },
  "scripts": {
    "start": "node server.js"
  },
  "readme": "#Juggernaut\n\nJuggernaut gives you a realtime connection between your servers and client browsers. \nYou can literally push data to clients using your web application, which lets you do awesome things like multiplayer gaming, chat, group collaboration and more. \n\nJuggernaut is built on top of [Node.js](http://nodejs.org) and is super simple and easy to get going. \n\n##Features\n\n* [Node.js](http://nodejs.org) server\n* Ruby client\n* Supports the following protocols:\n  * WebSocket\n  * Adobe Flash Socket\n  * ActiveX HTMLFile (IE)\n  * Server-Sent Events (Opera)\n  * XHR with multipart encoding\n  * XHR with long-polling\n* Horizontal scaling\n* Reconnection support \n* SSL support\n\nAs you can see, Juggernaut supports a variety of protocols. If one isn't supported by a client, Juggernaut will fallback to one that is. \n\nSupported browsers are:\n\n* Desktop\n  * Internet Explorer >= 5.5\n  * Safari >= 3\n  * Google Chrome >= 4\n  * Firefox >= 3\n  * Opera 10.61\n* Mobile\n  * iPhone Safari\n  * iPad Safari\n  * Android WebKit\n  * WebOs WebKit\n\n##Requirements\n\n* Node.js\n* Redis\n* Ruby (optional)\n\n##Setup\n\n###Install [Node.js](http://nodejs.org)\n\nIf you're using the [Brew](http://mxcl.github.com/homebrew) package management system, use that:\n\n    brew install node\n\nOr follow the [Node build instructions](https://github.com/joyent/node/wiki/Installation)\n\n###Install [Redis](http://code.google.com/p/redis)\n\nIf you're using the Brew package, use that:\n\n    brew install redis\n    \nOr follow the [Redis build instructions](http://redis.io/download)\n\n###Install Juggernaut\n\nJuggernaut is distributed by [npm](http://npmjs.org), you'll need to [install that](http://npmjs.org) first if you haven't already.\n\n    npm install -g juggernaut\n\n###Install the [Juggernaut client gem](http://rubygems.org/gems/juggernaut)\n\nThis step is optional, but if you're planning on using Juggernaut with Ruby, you'll need the gem.\n\n    gem install juggernaut\n\n##Running\n\nStart Redis:\n  \n    redis-server\n\nStart Juggernaut:\n\n    juggernaut\n\nThat's it! Now go to [http://localhost:8080](http://localhost:8080) to see Juggernaut in action.\n\n##Basic usage\n\nEverything in Juggernaut is done within the context of a channel. JavaScript clients can subscribe to a channel which your server can publish to.\nFirst, we need to include Juggernaut's application.js file. By default, Juggernaut is hosted on port 8080 - so we can just link to the file there.\n\n    <script src=\"http://localhost:8080/application.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    \nWe then need to instantiate the Juggernaut object and subscribe to the channel. As you can see, subscribe takes two arguments, the channel name and a callback.\n\n    <script type=\"text/javascript\" charset=\"utf-8\">\n      var jug = new Juggernaut;\n      jug.subscribe(\"channel1\", function(data){\n        console.log(\"Got data: \" + data);\n      });\n    </script>\n    \nThat's it for the client side. Now, to publish to the channel we'll write some Ruby:\n\n    require \"juggernaut\"\n    Juggernaut.publish(\"channel1\", \"Some data\")\n\nYou should see the data we sent appear instantly in the [open browser window](http://localhost:8080).\nAs well as strings, we can even pass objects, like so:\n\n    Juggernaut.publish(\"channel1\", {:some => \"data\"})\n\nThe publish method also takes an array of channels, in case you want to send a message to multiple channels co-currently. \n\n    Juggernaut.publish([\"channel1\", \"channel2\"], [\"foo\", \"bar\"])\n\nThat's pretty much the gist of it, the two methods - publish and subscribe. Couldn't be easier than that!\n\n##Flash\n\nAdobe Flash is optional, but it's the default fallback for a lot of browsers until WebSockets are supported.\nHowever, Flash needs a XML policy file to be served from port 843, which is restricted. You'll need to run Juggernaut with root privileges in order to open that port.\n\n    sudo juggernaut\n    \nYou'll also need to specify the location of WebSocketMain.swf. Either copy this file (from Juggernaut's public directory) to the root public directory of your application, or specify it's location before instantiating Juggernaut:\n\n    window.WEB_SOCKET_SWF_LOCATION = \"http://juggaddress:8080/WebSocketMain.swf\"\n    \nAs I mentioned above, using Flash with Juggernaut is optional - you don't have to run the server with root privileges. If Flash isn't available, Juggernaut will use [WebSockets](http://en.wikipedia.org/wiki/WebSocket) (the default), [Comet](http://goo.gl/lO6S) or polling. \n\n##SSL\n\nJuggernaut has SSL support! To activate, just put create a folder called 'keys' in the 'juggernaut' directory, \ncontaining your privatekey.pem and certificate.pem files. \n\n    >> mkdir keys\n    >> cd keys\n    >> openssl genrsa -out privatekey.pem 1024 \n    >> openssl req -new -key privatekey.pem -out certrequest.csr \n    >> openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem\n\nThen, pass the secure option when instantiating Juggernaut in JavaScript:\n\n    var juggernaut = new Juggernaut({secure: true})\n    \nAll Juggernaut's communication will now be encrypted by SSL.\n\n##Scaling\n\nThe only centralised (i.e. potential bottle neck) part to Juggernaut is Redis. \nRedis can support hundreds of thousands writes a second, so it's unlikely that will be an issue. \n\nScaling is just a case of starting up more Juggernaut Node servers, all sharing the same Redis instance. \nPut a TCP load balancer in front them, distribute clients with a Round Robin approach, and use sticky sessions. \n\nIt's worth noting that the latest WebSocket specification breaks support for a lot of HTTP load balancers, so it's safer just using a TCP one.\n\n##Client Events\n\nJuggernaut's JavaScript client has a few events that you can bind to:\n\n* connect\n* disconnect\n* reconnect\n\nJuggernaut also triggers data events in the context of an channel. You can bind to that event by just passing a callback to the subscribe function.\nHere's an example of event binding. We're using [jQuery UI](http://jqueryui.com) to show a popup when the client loses their connection to our server.\n\n    var jug = new Juggernaut;\n\n    var offline = $(\"<div></div>\")\n    \t.html(\"The connection has been disconnected! <br /> \" + \n    \t      \"Please go back online to use this service.\")\n    \t.dialog({\n    \t\tautoOpen: false,\n    \t\tmodal:    true,\n    \t\twidth:    330,\n    \t\tresizable: false,\n    \t\tcloseOnEscape: false,\n    \t\ttitle: \"Connection\"\n    \t});\n\n    jug.on(\"connect\", function(){ \n      offline.dialog(\"close\");\n    });\n\n    jug.on(\"disconnect\", function(){ \n      offline.dialog(\"open\");\n    });\n    \n    // Once we call subscribe, Juggernaut tries to connnect.\n    jug.subscribe(\"channel1\", function(data){\n      console.log(\"Got data: \" + data);\n    });\n\n##Excluding certain clients\n\nIt's a common use case to send messages to every client, except one. For example, this is a common chat scenario:\n\n* User creates chat message\n* User's client appends the message to the chat log, so the user sees it instantly\n* User's client sends an AJAX request to the server, notifying it of the new chat message\n* The server then publishes the chat message to all relevant clients\n\nNow, the issue above is if the server publishes the chat message back to the original client. In which case, it would get duplicated in the chat logs (as it already been created). We can resolve this issue by recording the client's Juggernaut ID, and then passing it as an `:except` option when Juggernaut publishes.\n\nYou can pass the Juggernaut session ID along with any AJAX requests by hooking into `beforeSend`, which is triggered by jQuery before sending any AJAX requests. The callback is passed an XMLHttpRequest, which we can use to set a custom header specifying the session ID.\n\n    var jug = new Juggernaut;\n    \n    jQuery.beforeSend(function(xhr){\n      xhr.setRequestHeader(\"X-Session-ID\", jug.sessionID);\n    });\n    \nNow, when we publish to a channel, we can pass the `:except` option, with the current client's session ID. \n\n    Juggernaut.publish(\n      \"/chat\",\n      params[:body],\n      :except => request.headers[\"X-Session-ID\"]\n    )\n    \nNow, the original client won't get the duplicated chat message, even if it's subscribed to the __/chat__ channel.\n\n##Server Events\n\nWhen a client connects & disconnects, Juggernaut triggers a callback. You can listen to these callbacks from the Ruby client,\n\n    Juggernaut.subscribe do |event, data|\n      # Use event/data\n    end\n\nThe event is either `:subscribe` or `:unsubscribe`. The data variable is just a hash of the client details:\n\n    {\"channel\" => \"channel1\", \"session_id\" => \"1822913980577141\", \"meta\" => \"foo\"}\n\n##Metadata\n\nYou'll notice there's a meta attribute in the server event example above. Juggernaut lets you attach meta data to the client object,\nwhich gets passed along to any server events. For example, you could set User ID meta data - then you would know which user was subscribing/unsubscribing to channels. You could use this information to build a live Roster of online users.\n\n    var jug = new Juggernaut;\n    jug.meta = {user_id: 1};\n    \n##Using Juggernaut from Python\n\nYou don't have to use Ruby to communicate with Juggernaut. In fact, all that is needed is a [Redis](http://code.google.com/p/redis) adapter. Here we're using [Python](http://www.python.org) with [redis-py](http://github.com/andymccurdy/redis-py).\n\n    import redis\n    import json\n\n    msg = {\n      \"channels\": [\"channel1\"],\n      \"data\": \"foo\"\n    }\n\n    r = redis.Redis()\n    r.publish(\"juggernaut\", json.dumps(msg))\n    \n##Using Juggernaut from Node.js\n\nSimilar to the Python example, we can use a Node.js Redis adapter to publish to Juggernaut.\n\n    var redis   = require(\"redis\");\n\n    var msg = {\n      \"channels\": [\"channel1\"],\n      \"data\": \"foo\"\n    };\n\n    var client = redis.createClient();\n    client.publish(\"juggernaut\", JSON.stringify(msg));\n\n##Building a Roster\n\nSo, let's take all we've learnt about Juggernaut, and apply it to something practical - a live chat roster.\nHere's the basic class. We're using [SuperModel](http://github.com/maccman/supermodel) with the Redis adapter. Any changes to the model will be saved to our Redis data store. We're also associating each Roster record with a user.\n\n    class Roster < SuperModel::Base\n      include SuperModel::Redis::Model\n      include SuperModel::Timestamp::Model\n\n      belongs_to :user\n      validates_presence_of :user_id\n  \n      indexes :user_id\n    end\n    \nNow let's integrate the Roster class with Juggernaut. We're going to listen to Juggernaut's server events - fetching the user_id out of the events meta data, and calling __event_subscribe__ or __event_unsubscribe__, depending on the event type.\n    \n    def self.subscribe\n      Juggernaut.subscribe do |event, data|\n        user_id = data[\"meta\"] && data[\"meta\"][\"user_id\"]\n        next unless user_id\n          \n        case event\n        when :subscribe\n          event_subscribe(user_id)\n        when :unsubscribe\n          event_unsubscribe(user_id)\n        end\n      end\n    end\n        \nLet's implement those two methods __event_subscribe__ & __event_unsubscribe__. We need to take into account they may be called multiple times for a particular user_id, if a User opens multiple browser windows co-currently. \n    \n    def event_subscribe(user_id)\n      record = find_by_user_id(user_id) || self.new(:user_id => user_id)\n      record.increment!\n    end\n\n    def event_unsubscribe(user_id)\n      record = find_by_user_id(user_id)\n      record && record.decrement!\n    end\n    \nWe need to add a __count__ attribute to the Roster class, so we can track if a client has completely disconnected from the system.\nWhenever clients subscribes to a channel, __increment!__ will get called and the __count__ attribute will be incremented, conversly whenever they disconnect from that channel __decrement!__ will get called and __count__ decremented.\n\n    attributes :count\n    \n    def count\n      read_attribute(:count) || 0\n    end\n\n    def increment!\n      self.count += 1\n      save!\n    end\n\n    def decrement!\n      self.count -= 1\n      self.count > 0 ? save! : destroy\n    end\n\nWhen __decrement!__ is called, we check to see if the count is zero, i.e. a client is no longer connected, and destroy the record if necessary. Now, at this point we have a live list of Roster records indicating who's online. We just need to call __Roster.subscribe__, say in a Rails script file, and Juggernaut events will be processed.\n\n    #!/usr/bin/env ruby\n    require File.expand_path('../../config/environment',  __FILE__)\n\n    puts \"Starting Roster\"\n    Roster.subscribe \n\nThere's no point, however, in having a live Roster unless we can show that to users - which is the subject of the next section, observing models. \n\n##Observing models\n\nWe can create an Juggernaut observer, which will observe some of the models, notifying clients when they're changed.\n\n    class JuggernautObserver < ActiveModel::Observer\n      observe :roster\n      \n      def after_create(rec)\n        publish(:create, rec)\n      end\n  \n      def after_update(rec)\n        publish(:update, rec)\n      end\n  \n      def after_destroy(rec)\n        publish(:destroy, rec)\n      end\n  \n      protected\n        def publish(type, rec)\n          channels = Array(rec.observer_clients).map {|c| \"/observer/#{c}\" }\n          Juggernaut.publish(\n            channels, \n            {\n              :id     => rec.id, \n              :type   => type, \n              :klass  => rec.class.name,\n              :record => rec\n            }\n          )\n        end\n    end\n    \nSo, you can see we're calling the publish method whenever a record is created/updated/destroyed. You'll notice that we're calling __observer_clients__ on the updated record. This is a method that application specific, and needs to be implemented on the Roster class. It needs to return an array of user_ids associated with the record.\n\nSo, as to the JavaScript side to the observer, we need to subscribe to a observer channel and set a callback. Now, whenever a __Roster__ record is created/destroyed, the process function will be called. We can then update the UI accordingly.\n\n    var process = function(msg){\n      // msg.klass\n      // msg.type\n      // msg.id\n      // msg.record \n    };\n    \n    var jug = new Juggernaut;\n    jug.subscribe(\"/observer/\" + user_id, process);\n\n##Full examples\n\nYou can see the full examples inside [Holla](http://github.com/maccman/holla), specifically [roster.rb](https://github.com/maccman/holla/blob/original/app/models/roster.rb),  [juggernaut_observer.rb](https://github.com/maccman/holla/blob/original/app/observers/juggernaut_observer.rb) and [application.juggernaut.js](https://github.com/maccman/holla/blob/original/app/javascripts/application.juggernaut.js).",
  "readmeFilename": "README.md",
  "_id": "juggernaut@2.1.1",
  "_from": "juggernaut@"
}
